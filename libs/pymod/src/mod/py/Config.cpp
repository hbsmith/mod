#include <mod/py/Common.hpp>

#include <mod/Config.hpp>

namespace mod {
namespace Py {

void Config_doExport() {
	// rst: .. py:class:: LabelType
	// rst:
	// rst:		Selector for which type of label to use in algorithms.
	// rst:
	py::enum_<mod::LabelType>("LabelType")
			// rst:		.. py:attribute:: String
			// rst:
			// rst:			Vertices and edges are considered to be labelled with
			// rst:			character strings. If only first-order terms are present,
			// rst:			then strings are generated as a serialisation of the term.
			.value("String", mod::LabelType::String)
			// rst:
			// rst:		.. py:attribute:: Term
			// rst:
			// rst:			Vertices and edges are considered to be labelled with
			// rst:			first-order terms. If only strings are present, then first-order
			// rst:			terms are generated by parsing the strings. This may result
			// rst:			in an :py:class:`TermParsingError` if a string can not be parsed.
			.value("Term", mod::LabelType::Term)
			;

	// rst: .. py:class:: LabelRelation
	// rst:
	// rst:		Selector for which type of labelled morphism to use in an algorithm.
	// rst:		For strings they are all defined to be equivalent to string equality.
	// rst:
	py::enum_<mod::LabelRelation>("LabelRelation")
			// rst:		.. py:attribute:: Isomorphism
			// rst:
			// rst:			Terms are considered isomorphic when their most general unifier
			// rst:			is a renaming.
			.value("Isomorphism", mod::LabelRelation::Isomorphism)
			// rst:		.. py:attribute:: Specialisation
			// rst:
			// rst:			A term :math:`t_2` is more special than, or isomorphic to, a term :math:`t_1` if there is a substitution
			// rst:			which can be applied to :math: `t_1` to make the terms equal.
			// rst:			This relation means that the right-hand side of a comparison is the more specialised term.
			.value("Specialisation", mod::LabelRelation::Specialisation)
			// rst:		.. py:attribute:: Unification
			// rst:
			// rst:			Terms unify if a most general unifier (MGU) exists. The found MGU
			// rst:			is used for substitution in some algorithms.
			.value("Unification", mod::LabelRelation::Unification)
			;

	// rst: .. py:class:: LabelSettings
	// rst:
	// rst:		A group label settings commonly used together in algorithms.
	// rst:
	py::class_<mod::LabelSettings>("LabelSettings", py::no_init)
			// rst: 	.. py:method:: __init__(self, type, relation)
			// rst:
			// rst:			Construct label settings that only uses the vertex and edge labels.
			// rst:
			// rst:			:param type: How to interpret labels.
			// rst: 		:type type: :py:class:`LabelType`
			// rst:			:param relation: The relation that should hold in morphisms between two labels.
			// rst: 		:type relation: :py:class:`LabelRelation`
			.def(py::init < mod::LabelType, mod::LabelRelation> ())
			// rst: 	.. py:method:: __init__(self, type, relation, stereoRelation)
			// rst:
			// rst:			Construct label settings that include both vertex and edge labels, and stereo information.
			// rst:
			// rst:			:param type: How to interpret labels.
			// rst: 		:type type: :py:class:`LabelType`
			// rst:			:param relation: The relation that should hold in morphisms between two labels.
			// rst: 		:type relation: :py:class:`LabelRelation`
			// rst:			:param stereoRelation: The relation that should hold in morphisms between stereo data.
			// rst:			:type stereoRelation: :py:class:`LabelRelation`
			.def(py::init < mod::LabelType, mod::LabelRelation, mod::LabelRelation > ())
			// rst: 	.. py:method:: __init__(self, type, relation, withStereo, stereoRelation)
			// rst:
			// rst:			Construct label settings that includes vertex and edge labels, and stereo information depending on the given flag.
			// rst:
			// rst:			:param type: How to interpret labels.
			// rst: 		:type type: :py:class:`LabelType`
			// rst:			:param relation: The relation that should hold in morphisms between two labels.
			// rst: 		:type relation: :py:class:`LabelRelation`
			// rst:			:param withStereo: A flag to specify if stereo information should be included.
			// rst:			:type withStereo: bool
			// rst:			:param stereoRelation: The relation that should hold in morphisms between stereo data.
			// rst:			:type stereoRelation: :py:class:`LabelRelation`
			.def(py::init < mod::LabelType, mod::LabelRelation, bool, mod::LabelRelation > ())
			// rst:		.. py:attribute:: type
			// rst:
			// rst:			:type: :py:class:`LabelType`
			.def_readwrite("type", &mod::LabelSettings::type)
			// rst:		.. py:attribute:: relation
			// rst:
			// rst:			:type: :py:class:`LabelRelation`
			.def_readwrite("relation", &mod::LabelSettings::relation)
			// rst:		.. py:attribute:: withStereo
			// rst:
			// rst:			:type: bool
			.def_readwrite("withStereo", &mod::LabelSettings::withStereo)
			// rst:		.. py:attribute:: stereoRelation
			// rst:
			// rst:			:type: :py:class:`LabelRelation`
			.def_readwrite("stereoRelation", &mod::LabelSettings::stereoRelation)
			;

#define NSIter(rNS, dataNS, tNS)                                                \
			BOOST_PP_SEQ_FOR_EACH_I(SettingIter, ~,                                   \
				BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 2, tNS))
#define SettingIter(rSetting, dataSetting, iSetting, tSetting)                  \
			(BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_SETTING_SIZE(), 0, tSetting))

#undef NSIter
#undef SettingIter

	auto configClass = py::class_<mod::Config, boost::noncopyable>("Config", py::no_init);
	{ // Config scope
		py::scope configScope = configClass;
		py::enum_<mod::Config::IsomorphismAlg>("IsomorphismAlg")
				.value("VF2", mod::Config::IsomorphismAlg::VF2)
				.value("Canon", mod::Config::IsomorphismAlg::Canon)
				.value("SmilesCanonVF2", mod::Config::IsomorphismAlg::SmilesCanonVF2)
				;

#define NSIter(rNS, dataNS, tNS)                                                                        \
	py::class_<mod::Config:: BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 0, tNS), boost::noncopyable> \
		("Config" MOD_toString(BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 0, tNS)), py::no_init)      \
			BOOST_PP_SEQ_FOR_EACH_I(SettingIter,                                                           \
				BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 0, tNS),                                     \
				BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 2, tNS))                                     \
		;
#define SettingIter(rSetting, dataSetting, iSetting, tSetting)                  \
		.add_property(AddConfig(                                                  \
			BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_SETTING_SIZE(), 0, tSetting),      \
			BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_SETTING_SIZE(), 1, tSetting),      \
			dataSetting                                                            \
		))
#define AddConfig(Type, Name, Class)                                            \
	MOD_toString(Name),                                                          \
	py::make_function([] (mod::Config::Class *c) -> Type {                       \
			return c->Name.get();                                                  \
		},                                                                        \
		py::default_call_policies(),                                              \
		boost::mpl::vector<Type, mod::Config::Class*>()),                         \
	py::make_function([] (mod::Config::Class *c, Type t) -> void {               \
			c->Name.set(t);                                                        \
		},                                                                        \
		py::default_call_policies(),                                              \
		boost::mpl::vector<void, mod::Config::Class*, Type>())

		BOOST_PP_SEQ_FOR_EACH(NSIter, ~, MOD_CONFIG_DATA())

#undef NSIter
#undef SettingIter
#undef AddConfig

		py::list classNames;
#define NSIter(rNS, dataNS, tNS)                                                \
		classNames.append<std::string>("Config" MOD_toString(BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 0, tNS)));
		BOOST_PP_SEQ_FOR_EACH(NSIter, ~, MOD_CONFIG_DATA())
#undef NSIter
				configScope.attr("classNames") = classNames;
	} // Config scope

#define NSIter(rNS, dataNS, tNS)                                                       \
	.def_readonly(MOD_toString(BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 1, tNS)), \
		&mod::Config::BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 1, tNS))

	configClass
	BOOST_PP_SEQ_FOR_EACH(NSIter, ~, MOD_CONFIG_DATA())
			;

#undef NSIter
#undef SettingIter

	// rst: .. py:class:: Config
	// rst:
	// rst:		This class contains a range of inner classes of config settings. See :doc:`the libMÃ˜D documentation</libmod/Config>`.

	// rst: .. py:data:: config
	// rst:
	// rst:		This variable is initialised to the return value of :py:func:`getConfig`, i.e., just use this instead of the method.
	// rst:
	// rst: .. py:method:: getConfig()
	// rst:
	// rst:		:returns: the singleton :cpp:class:`Config` instance used by the library.
	py::def("getConfig", &mod::getConfig, py::return_value_policy<py::reference_existing_object>());
}

} // namespace Py
} // namespace mod
