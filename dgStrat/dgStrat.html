
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>7. Derivation Graph Strategies &#8212; MØD 0.9.0 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="8. Known Issues" href="../knownIssues.html" />
    <link rel="prev" title="6. Data Formats" href="../dataDesc/dataDesc.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../knownIssues.html" title="8. Known Issues"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../dataDesc/dataDesc.html" title="6. Data Formats"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">MØD 0.9.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="derivation-graph-strategies">
<span id="dgstrat"></span><h1>7. Derivation Graph Strategies<a class="headerlink" href="#derivation-graph-strategies" title="Permalink to this headline">¶</a></h1>
<p>The strategy framework is a domain specific programming language for
specifying the application of transformation rules.
It can therefore be used to perform computations with graphs and graph
rewriting.
During evaluation of a strategy the framework will remember each graph
derivation performed, and store them as a directed multi-hypergraph,
i.e., a derivation graph.
When graphs model molecules and transformation rules model reaction
patterns, then the resulting derivation graph can be seen as a chemical
reaction network.
Here we describe the semantics of the strategy language,
while the API is described seperately for the
<a class="reference internal" href="../libmod/dg/Strategies.html#cpp-dg-strategies"><span class="std std-ref">C++</span></a> and <a class="reference internal" href="../pymod/dg/Strategies.html#py-dg-strategies"><span class="std std-ref">Python</span></a> interface.</p>
<div class="section" id="virtual-machine">
<h2>7.1. Virtual Machine<a class="headerlink" href="#virtual-machine" title="Permalink to this headline">¶</a></h2>
<p>The strategies are evaluated in a virtual machine.
Its state is a pair <span class="math notranslate nohighlight">\(F = (\mathcal{U}, \mathcal{S})\)</span>
of sets of graphs, where <span class="math notranslate nohighlight">\(\mathcal{U}\)</span> is called the <cite>universe</cite>.
The set <span class="math notranslate nohighlight">\(\mathcal{S}\)</span> is a distinguished subset of the universe
called the <cite>active subset</cite>.
The machine additionally keeps track of a directed multi-hypergraph
<span class="math notranslate nohighlight">\(\mathcal{H} = (V, E)\)</span>, called a <cite>derivation graph</cite>.
The vertices of <span class="math notranslate nohighlight">\(\mathcal{H}\)</span> each has an associated graph,
while each hyperedge has an associated list of rules.</p>
<p>Initially the state is empty, i.e.,
<span class="math notranslate nohighlight">\((\mathcal{U}, \mathcal{S}) = (\emptyset, \emptyset)\)</span>
and the derivation graph is the empty hypergraph.</p>
</div>
<div class="section" id="strategies">
<h2>7.2. Strategies<a class="headerlink" href="#strategies" title="Permalink to this headline">¶</a></h2>
<p>Each strategy is a function taking a graph state <span class="math notranslate nohighlight">\(F = (\mathcal{U}, \mathcal{S})\)</span> as
input and returning a new state <span class="math notranslate nohighlight">\(F' = (\mathcal{U}', \mathcal{S}')\)</span>.
While the universe and active subset of a state are described as sets of graphs,
they are implemented as lists of unique graphs.
The result of most strategies do not depend on the order of the graphs and make no guarentees
about the order in the results.</p>
<div class="section" id="add-universe">
<span id="strat-adduniverse"></span><h3>7.2.1. Add Universe<a class="headerlink" href="#add-universe" title="Permalink to this headline">¶</a></h3>
<p>Given a single graph, a set of graphs, or a function returning a set of graphs,
this strategy returns the graph state with the additional graphs added to the universe.
That is, if <span class="math notranslate nohighlight">\(\mathcal{G}\)</span> is the set of graphs to be added,
then the result is <span class="math notranslate nohighlight">\((\mathcal{U}\cup \mathcal{G}, \mathcal{S})\)</span>.</p>
</div>
<div class="section" id="add-subset">
<span id="strat-addsubset"></span><h3>7.2.2. Add Subset<a class="headerlink" href="#add-subset" title="Permalink to this headline">¶</a></h3>
<p>This strategy is analogous to the previous strategy,
except the graphs are added to both the universe and the active subset.
That is, the result is <span class="math notranslate nohighlight">\((\mathcal{U}\cup \mathcal{G}, \mathcal{S}\cup \mathcal{G})\)</span>.</p>
</div>
<div class="section" id="execute">
<span id="strat-execute"></span><h3>7.2.3. Execute<a class="headerlink" href="#execute" title="Permalink to this headline">¶</a></h3>
<p>The <cite>execute</cite> strategy is simply the identity function, but it can be used to execute arbitrary code
at a given point during evalutation.</p>
</div>
<div class="section" id="filter-universe">
<span id="strat-filteruniverse"></span><h3>7.2.4. Filter Universe<a class="headerlink" href="#filter-universe" title="Permalink to this headline">¶</a></h3>
<p>This strategy can be used to remove graphs from the input state, using a given predicate.
Assuming this predicate is <span class="math notranslate nohighlight">\(p\)</span>, then the result is <span class="math notranslate nohighlight">\(F' = (\mathcal{U}', \mathcal{S}')\)</span>,
with <span class="math notranslate nohighlight">\(\mathcal{U}' = \{g\in \mathcal{U}\mid p(g)\}\)</span>
and <span class="math notranslate nohighlight">\(\mathcal{S}' = \{g\in \mathcal{S}\mid p(g)\}\)</span>.</p>
</div>
<div class="section" id="filter-subset">
<span id="strat-filtersubset"></span><h3>7.2.5. Filter Subset<a class="headerlink" href="#filter-subset" title="Permalink to this headline">¶</a></h3>
<p>As the previous strategy this one also filters the input state, but only the active subset.
The result is thus <span class="math notranslate nohighlight">\(F' = (\mathcal{U}, \mathcal{S}')\)</span>,
with <span class="math notranslate nohighlight">\(\mathcal{S}' = \{g\in \mathcal{S}\mid p(g)\}\)</span>.</p>
</div>
<div class="section" id="rule">
<span id="strat-rule"></span><h3>7.2.6. Rule<a class="headerlink" href="#rule" title="Permalink to this headline">¶</a></h3>
<p>A rule (<a class="reference internal" href="../libmod/rule/Rule.html#_CPPv4N3mod4rule4RuleE" title="mod::rule::Rule"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">C++</span></code></a>/<a class="reference internal" href="../pymod/rule/Rule.html#mod.Rule" title="mod.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">Python</span></code></a>) can be used directly as a strategy.
It will search for proper derivations using a multiset of graphhs drawn from the input unvierse.
However, each candidate multiset will have at least one graph from the active subset.
Newly discovered graphs will be the active subset of the output.
That is, if <span class="math notranslate nohighlight">\(D = \{G\Rightarrow^{p} H\mid G\subseteq \mathcal{U} \wedge G\cap \mathcal{S} \neq \emptyset\}\)</span>
is the set of all proper derivations using at least one graph from the active input subset,
then the resutl is <span class="math notranslate nohighlight">\(F' = (\mathcal{U}', \mathcal{S}')\)</span> with
<span class="math notranslate nohighlight">\(\mathcal{S}' = \bigcup_{G\Rightarrow^{p} H\in D} H\backslash \mathcal{U}\)</span>,
and <span class="math notranslate nohighlight">\(\mathcal{U}' = \mathcal{U}\cup \mathcal{S}'\)</span>.</p>
<p>As a side-effect of evaluating a rule strategy the underlying derivation graph is augmented with vertices for every new graph discovered.
The derivations in <span class="math notranslate nohighlight">\(D\)</span> is additionally added as directed multi-hyperedges in the graph.</p>
</div>
<div class="section" id="derivation-predicates">
<span id="strat-rightpredicate"></span><span id="strat-leftpredicate"></span><h3>7.2.7. Derivation Predicates<a class="headerlink" href="#derivation-predicates" title="Permalink to this headline">¶</a></h3>
<p>A derivation predicate strategy changes the execution environment for a given substrategy <span class="math notranslate nohighlight">\(Q\)</span>.
Whenever a derivation is discovered during the evaluation of <span class="math notranslate nohighlight">\(Q\)</span> a predicate <span class="math notranslate nohighlight">\(p\)</span> will be consulted before
the derivation is finally accepted.
There are two flavours of the derivation predicate strategy: left predicate and right predicate.
The difference between them is that only the left-hand side of a potential derivation and the rule is available in the left predicate,
while the whole derivation is available in the right predicate.
Left predicatates are thus not strictly necessary, but can potentially be slightly more efficient than right predicates.</p>
</div>
<div class="section" id="parallel">
<span id="strat-parallel"></span><h3>7.2.8. Parallel<a class="headerlink" href="#parallel" title="Permalink to this headline">¶</a></h3>
<p>A <cite>parallel</cite> strategy aggregates a set of substrategies <span class="math notranslate nohighlight">\(\{Q_1, Q_2, \dots, Q_n\}\)</span> and evaluates them on the same input state.
This evaluation produces a set of output states <span class="math notranslate nohighlight">\(\{F_1', F_2', \dots, F_n'\}\)</span>, and the final result is the union of those states:
<span class="math notranslate nohighlight">\(\mathcal{U}' = \bigcup_{1\leq i\leq n} \mathcal{U}_i'\)</span>,
<span class="math notranslate nohighlight">\(\mathcal{S}' = \bigcup_{1\leq i\leq n} \mathcal{S}_i'\)</span>.</p>
</div>
<div class="section" id="sequence">
<span id="strat-sequence"></span><h3>7.2.9. Sequence<a class="headerlink" href="#sequence" title="Permalink to this headline">¶</a></h3>
<p>Given two substrategies <span class="math notranslate nohighlight">\(Q_1\)</span> and <span class="math notranslate nohighlight">\(Q_2\)</span>, the sequence strategy evaluates the composition of the strategies, i.e.,
with the input state <span class="math notranslate nohighlight">\(F\)</span> the output is <span class="math notranslate nohighlight">\(Q_2(Q_1(F))\)</span>.</p>
</div>
<div class="section" id="repeat">
<span id="strat-repeat"></span><h3>7.2.10. Repeat<a class="headerlink" href="#repeat" title="Permalink to this headline">¶</a></h3>
<p>The repetition strategy acts as a loop that evaluates a given substrategy <span class="math notranslate nohighlight">\(Q\)</span> in sequence with it self a certain number of times.
Let <span class="math notranslate nohighlight">\(Q^k(F)\)</span> be the <span class="math notranslate nohighlight">\(k\)</span>-fold composition of the strategy <span class="math notranslate nohighlight">\(Q\)</span> on the input state <span class="math notranslate nohighlight">\(F\)</span>.
Notably, for <span class="math notranslate nohighlight">\(k = 0\)</span> we have the identity function.
Given a constant <span class="math notranslate nohighlight">\(n\geq 0\)</span>, the repeatition strategy on <span class="math notranslate nohighlight">\(Q\)</span> results in <span class="math notranslate nohighlight">\(F' = Q\)</span>,
where <span class="math notranslate nohighlight">\(k = min\{0, 1, \dots, n\}\)</span> such that either
<span class="math notranslate nohighlight">\(k = n\)</span>, or
<span class="math notranslate nohighlight">\(Q^{k+1}(F) = Q^{k}(F)\)</span>, or
<span class="math notranslate nohighlight">\(Q^{k+1}(F) = (\emptyset, \overline{\mathcal{U}})\)</span>
for an abitrary universe <span class="math notranslate nohighlight">\(\overline{\mathcal{U}}\)</span>.</p>
</div>
<div class="section" id="revive">
<span id="strat-revive"></span><h3>7.2.11. Revive<a class="headerlink" href="#revive" title="Permalink to this headline">¶</a></h3>
<p>A revive strategy is manipulating the output of an inner strategy <span class="math notranslate nohighlight">\(Q\)</span>, depending on which derivations are discovered by <span class="math notranslate nohighlight">\(Q\)</span>.
Let <span class="math notranslate nohighlight">\(F = (\mathcal{U}, \mathcal{S})\)</span> be the input state and <span class="math notranslate nohighlight">\(\overline{F} = (\overline{\mathcal{U}}, \overline{\mathcal{S}}) = Q(F)\)</span>.
Further, let <span class="math notranslate nohighlight">\(D\)</span> be the set of derivations discovered (and accepted by the predicates) in the evaluation of <span class="math notranslate nohighlight">\(Q(F)\)</span>.
We then define the set of <cite>consumed</cite> graphs as those being on the right side on any derivation in <span class="math notranslate nohighlight">\(D\)</span>: <span class="math notranslate nohighlight">\(C = \bigcup_{G\Rightarrow H \in D} G\)</span>.
As output of the revive strategy we do not modify the universe, i.e., <span class="math notranslate nohighlight">\(\mathcal{U}' = \overline{\mathcal{U}}\)</span>.
The output subset is however extended by non-consumed graphs that were in the input subset:
<span class="math notranslate nohighlight">\(\mathcal{S}' = \overline{\mathcal{S}}\cup \mathcal{S}\backslash C\)</span>.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">7. Derivation Graph Strategies</a><ul>
<li><a class="reference internal" href="#virtual-machine">7.1. Virtual Machine</a></li>
<li><a class="reference internal" href="#strategies">7.2. Strategies</a><ul>
<li><a class="reference internal" href="#add-universe">7.2.1. Add Universe</a></li>
<li><a class="reference internal" href="#add-subset">7.2.2. Add Subset</a></li>
<li><a class="reference internal" href="#execute">7.2.3. Execute</a></li>
<li><a class="reference internal" href="#filter-universe">7.2.4. Filter Universe</a></li>
<li><a class="reference internal" href="#filter-subset">7.2.5. Filter Subset</a></li>
<li><a class="reference internal" href="#rule">7.2.6. Rule</a></li>
<li><a class="reference internal" href="#derivation-predicates">7.2.7. Derivation Predicates</a></li>
<li><a class="reference internal" href="#parallel">7.2.8. Parallel</a></li>
<li><a class="reference internal" href="#sequence">7.2.9. Sequence</a></li>
<li><a class="reference internal" href="#repeat">7.2.10. Repeat</a></li>
<li><a class="reference internal" href="#revive">7.2.11. Revive</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../dataDesc/dataDesc.html"
                        title="previous chapter">6. Data Formats</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../knownIssues.html"
                        title="next chapter">8. Known Issues</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/dgStrat/dgStrat.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../knownIssues.html" title="8. Known Issues"
             >next</a> |</li>
        <li class="right" >
          <a href="../dataDesc/dataDesc.html" title="6. Data Formats"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">MØD 0.9.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2013-2018, Jakob Lykke Andersen.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.3+/83a3b7a8.
    </div>
  </body>
</html>